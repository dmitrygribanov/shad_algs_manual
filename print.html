<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Курс Алгоритмов ШАД</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/spoiler.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Вступление</a></li><li class="chapter-item expanded "><a href="styleguide.html"><strong aria-hidden="true">2.</strong> Стайлгайд</a></li><li class="chapter-item expanded "><a href="assignments.html"><strong aria-hidden="true">3.</strong> Как сдавать домашние задания</a></li><li class="chapter-item expanded "><a href="environment.html"><strong aria-hidden="true">4.</strong> Как настроить окружение на своем компьютере</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">5.</strong> Что делать, если решение не проходит в контесте</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Курс Алгоритмов ШАД</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://gitlab.com/ysda/algorithms" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Здесь находится информация о том, как сдать курс алгоритмов и выжить</p>
<h2 id="Ссылки"><a class="header" href="#Ссылки">Ссылки</a></h2>
<ul>
<li><a href="https://lk.yandexdataschool.ru/courses/2020-autumn/7.821-algorithms-1/">Страница курса в LMS</a>. Здесь находится расписание занятий, список выложенных домашек, дедлайны и т.д.</li>
<li><a href="./styleguide.html">Styleguide</a> — обязателен к прочтению и <strong>соблюдению</strong>.</li>
<li><a href="./assignments.html">Как сдавать домашние задания</a></li>
<li><a href="./environment.html">Как настроить окружение на своем компьютере</a></li>
<li><a href="./troubleshooting.html">Что делать, если решение не проходит в контесте</a></li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<ul>
<li>Как получить доступ к Яндекс.Контесту? На странице курса в LMS есть ссылка на форму, которую нужно заполнить.
<ul>
<li>Я заполнил форму, почему ничего не произошло? Доступ даётся не автоматически, должен появиться в течении суток.</li>
</ul>
</li>
<li>Почему за посылки в Яндекс.Контесте снимаются баллы? <a href="./assignments.html#%D0%92%D0%B5%D1%80%D0%B4%D0%B8%D0%BA%D1%82%D1%8B-%D0%BF%D0%BE-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5">Читай вики</a>.</li>
<li>Почему на компьютере решение работает, а в контесте падает? <a href="./troubleshooting.html">Читай вики</a>.</li>
<li>...</li>
<li>...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Стайлгайд"><a class="header" href="#Стайлгайд">Стайлгайд</a></h1>
<h2 id="Основные-правила"><a class="header" href="#Основные-правила">Основные правила</a></h2>
<p>Прежде, чем писать какой-либо код, обязательно прочитайте C++ Style Guide, на нашем курсе мы требуем полного выполнения 
<a href="http://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></p>
<details><summary>Какие пункты из Google C++ Style Guide наиболее важны:</summary>
<ul>
<li>Scoping
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#Local_Variables">Local Variables</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables">Static and Global Variables</a></li>
</ul>
</li>
<li>Classes
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#Doing_Work_in_Constructors">Doing Work in Constructors</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Implicit_Conversions">Implicit Conversions</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Structs_vs._Classes">Structs vs. Classes</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Access_Control">Access Control</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Declaration_Order">Declaration Order</a></li>
</ul>
</li>
<li>Functions
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#Function_Parameter_Ordering">Parameter Ordering</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Write_Short_Functions">Write Short Functions</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Reference_Arguments">Reference Arguments</a> (с оговоркой про выходные параметры примитивных типов в <a href="styleguide.html#input_params">п. 14</a>)</li>
</ul>
</li>
<li>Other C++ Features
<ul>
<li><a href="http://google.github.io/styleguide/cppguide.html#Casting">Casting</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement">Preincrement and Predecrement</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Use_of_const">Use of const</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Use_of_constexpr">Use of constexpr</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Integer_Types">Integer Types</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#0_and_nullptr/NULL">0 and nullptr/NULL</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#auto">auto</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Braced_Initializer_List">Braced Initializer List</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Lambda_expressions">Lambda Expressions</a></li>
</ul>
</li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Naming">Naming</a></li>
<li><a href="http://google.github.io/styleguide/cppguide.html#Formatting">Formatting</a></li>
</ul>
</details>
<p>Ваша задача на этом курсе — написать наиболее простой, понятный, читаемый и гибкий код среди тех, которые проходят ограничения по времени и по памяти. То есть в первую очередь должна быть правильной асимптотическая сложность, а потом сразу же думайте, как все сделать максимально просто. </p>
<p><strong>Боритесь с дублированием кода</strong></p>
<p><em><strong>Это самое большое возможное зло</strong></em>. Если в процессе написания вам понадобилось копировать и вставить кусок своего кода в этот же код, то это первый признак того, что происходит дублирование. Постарайтесь детектировать идентичные и похожие места, вынесите общую часть в отдельную функцию или класс и воспользуйтесь ей дважды с разными аргументами.</p>
<p><strong>Старайтесь писать аккуратно</strong></p>
<p>Удаляйте лишний, неиспользуемый, закомментированный код, удаляйте переменные и функции, которые вам на самом деле не нужны, остальные называйте понятно.</p>
<h3 id="Синтаксис"><a class="header" href="#Синтаксис">Синтаксис</a></h3>
<p>На код должно быть приятно смотреть, его должно быть легко читать. Вы его пишете один раз, сохраняете, после чего его читают много раз, поэтому выгодно потратить при написании немного времени на приведение кода в порядок, чтобы впоследствии сократить своё и чужое время на чтение.
Простые правила ниже служат для улучшения визуального восприятия.</p>
<ul>
<li>
<p>Используйте 4 пробела для отступа. Данный размер отступа является наиболее распространенным, требуется на курсе C++, поэтому используйте его всюду для единообразия. 4 пробела также является оптимальным размером для отступа согласно <a href="http://homepages.inf.ed.ac.uk/dts/pm/Papers/nasa-c-style.pdf">NASA</a>.</p>
</li>
<li>
<p>Вокруг всех бинарных операторов (<code>=, ==, +, -, *, /, &gt;, &lt;&lt;</code> и др.) должны быть пробелы с обеих сторон. Исключением являются операторы <code>., -&gt;, ::</code>.</p>
</li>
<li>
<p>После запятой должен быть пробел. </p>
</li>
<li>
<p>Между закрывающейся круглой скобкой и открывающейся фигурной должен быть пробел.</p>
</li>
<li>
<p>Не жадничайте с пустыми строками. Вставляйте всегда пустые строки между определениями глобальных функций, классов, констант, typedef'ов, include'ов, между объявлениями методов и функций, между реализациями функций, между объявлениями классов и реализациями функций и т.д.</p>
</li>
<li>
<p>Вставляйте пустые строки в код реализации функций, чтобы подчеркнуть разделение логических частей кода.</p>
</li>
<li>
<p>Не размещайте if, else, for, while и др. на одной строке со своим statement:</p>
<pre><code class="language-C++">if (condition) statement;
else statement;
...
for (...) statement;
</code></pre>
<p>Это, во-первых, ухудшает читаемость кода. Вы можете вообще один из statement'ов не заметить или ошибочно решить, что он относится к if'у:</p>
<pre><code class="language-C++">if (number % 2 == 0) std::cout &lt;&lt; &quot;Even\n&quot;; even = true;
</code></pre>
<p>А во-вторых, при отладке debugger'ом невозможно понять, выполнив команду «Step Over», выполнилось или не выполнилось условие (или сколько итераций цикла прошло).</p>
</li>
<li>
<p>Также рекомендуется всегда обрамлять <code>if, else, for, while</code> фигурными скобками:</p>
<pre><code class="language-C++">for (size_t index = 0; index &lt; array.size(); ++index) {
    statement1;
    statement2;
    ...
}
</code></pre>
<pre><code class="language-C++">for (auto number : array) {
    statement1;
    statement2;
    ...
}
</code></pre>
<p>даже если внутри только один <code>statement</code>.</p>
<pre><code class="language-C++">if (number % 2 == 0) {
    std::cout &lt;&lt; &quot;Even\n&quot;;
}
</code></pre>
<p>Это более читаемо и безопасно. В варианте без скобок легко ошибиться, например, вот так:</p>
<pre><code class="language-C++">if (number % 2 == 0)
    std::cout &lt;&lt; &quot;Even\n&quot;;
    even = true;
</code></pre>
<p>Легко подумать, что код <code>even = true;</code> тоже находится под if'ом.</p>
</li>
</ul>
<h3 id="Язык-c"><a class="header" href="#Язык-c">Язык C++</a></h3>
<p>Существуют разные языки программирования: C, C++, Java, Python и великое множество других. Между ними есть очевидные внешние сходства и различия: как написать цикл, как определить оператор, как создать класс. Однако основные их отличия кроются в принятых в них методах решения типовых задач и инструментах: если писать цикл по индексу, то какие должны быть его границы? если определить оператор, каков должен быть тип принимаемых аргументов и возвращаемого значения? если создавать класс, какие переменные-члены стоит в нем определять, какие методы, что следует вынести во внешние функции? На все эти вопросы можно дать разные ответы, и все они будут отчасти верными. Есть и общие рекомендации и конструкции, которые зарекомендовали себя за долгое время использования, как надежные и удобные, а также примеры, как делать не надо. Некоторые из них описаны в этом разделе.</p>
<ol>
<li>
<p><code>using namespace std;</code> использовать нельзя.<details><summary>Подрообнее</summary>
Включать целый namespace опасно, так как из-за этого может возникнуть конфликт имен. Вследствие чего могут возникнуть нетривиальные ошибки компиляции/линковки, а если не повезет, то переменная из namespace может совпасть по названию с какой-то вашей переменной, про которую вы не помните ее область видимости, что приведет к еще более сложнонаходимым багам, хоть все и скомпилируется, но иногда вы будете использовать переменную, думая, что это ваша переменная, и в ней такое-то значение, а значение будет совсем другим. Если нужно использовать много раз <code>std::vector</code>, напишите <code>using std::vector;</code> если <code>cout</code>, то <code>using std::cout;</code> и т.д. Кроме того, включая <code>namespace</code>, вы нарушаете сам принцип использования namespace'ов.</details></p>
</li>
<li>
<p>Использовать массивы фиксированной длины <code>int[]</code>, <code>int*</code> не рекомендуется — используйте вместо них <code>std::vector&lt;int&gt;</code>.</p>
</li>
<li>
<p>Не используйте C-type строки <code>char[]</code> и <code>char*</code> - используйте вместо них <code>std::string</code>.</p>
</li>
<li>
<p>Не используйте ввод-вывод в стиле С через функции scanf, printf. <details><summary>Подробнее</summary>
Используйте вместо них операторы <code>&gt;&gt;</code> и <code>&lt;&lt;</code> у <code>std::cin</code> и <code>std::cout</code> соответственно. Если при этом в задаче большой размер ввода-вывода (от 100000 чисел), то необходимо использовать несколько дополнительных приемов, чтобы ваш ввод-вывод работал достаточно быстро, иначе вы можете получить Time Limit Exceeded. Эти приемы описаны ниже.</details></p>
<details><summary>Пример на пункты 1 &mdash; 4:</summary>
<pre><code class="language-C++">#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using std::string;
using std::vector;

vector&lt;string&gt; Input() {
    size_t rows;
    std::cin &gt;&gt; rows;
    vector&lt;string&gt; table;
    table.reserve(rows);
    for (size_t row = 0; row &lt; rows; ++row) {
        std::string line;
        std::cin &gt;&gt; line;
        table.push_back(line);
    }
    return table;
}

vector&lt;string&gt; Process(vector&lt;string&gt; table) {
    std::reverse(table.begin(), table.end());
    return table;
}

void Output(const vector&lt;string&gt;&amp; table) {
    for (const auto&amp; row : table) {
        std::cout &lt;&lt; row &lt;&lt; std::endl;
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    const auto&amp; table = Input();
    table = Process(table);
    Output(table);
    return 0;
}
</code></pre>
</details>
<p><strong>Важно</strong> По умолчанию для <code>iostream</code> включен режим совместимости с <code>stdio</code>, который позволяет одновременно использовать оба интерфейса для ввода/вывода. В этом режиме производительность <code>std::cin</code> и <code>std::cout</code> понижается в несколько раз. <details><summary>Подробнее</summary>
Поэтому если размер ввода/вывода имеет порядок от 100000 чисел, вам надо будет отключить этот режим. Делать это надо до совершения каких-либо операций ввода-вывода, желательно первой же строкой в программе:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

int main() {
    std::ios_base::sync_with_stdio(false);
    ...
    return 0;
}
</code></pre>
<p>Также обратите внимание на то, что <code>std::cout</code> может работать слишком медленно, если вы выводите порядка 100000 чисел или более, и при этом у <code>std::cout</code> регулярно очищается буфер. Буфер очищается при каждом выводе <code>std::endl</code>, так что в случае большого вывода лучше выводить <code>&quot;\n&quot;</code> вместо <code>std::endl</code>. Также буфер <code>std::cout</code> очищается при каждом вводе через <code>std::cin</code> — это связано с тем, что при пользовательском вводе-выводе через обычный <code>std::cin</code> и <code>std::cout</code> в консоли необходимо перед тем, как запрашивать очередной ввод от пользователя, показать ему последний вывод перед этим, а значит и очистить буфер. Эта проблема для задач с большим выводом решается с помощью вызова <code>std::cin.tie(nullptr);</code> в самом начале программы. Выполнение всех этих рекомендаций приведет к тому, что ввод-вывод при помощи потоков <code>std::cin</code> и <code>std::cout</code> будет работать не медленнее ввода-вывода через <code>printf</code> и <code>scanf</code> на задачах с большим вводом-выводом. Подробнее см. <a href="http://stackoverflow.com/questions/9274057">здесь</a>.</details></p>
</li>
<li>
<p>Если используется значение типа истина/ложь, то используйте тип <code>bool</code>, а не <code>int</code>.</p>
</li>
<li>
<p>Не используйте тип <code>long</code>. <details><summary>Подробнее</summary>
Более стандартный тип — <code>int</code>, к нему у всех уже привыкли глаза, и <code>long</code> с теми же намерениями — просто смотрится странно. На 32-битных машинах оба типа являются 32-битными и ничем не отличаются, поэтому используйте <code>int</code> вместо <code>long</code>. Если вам нужен 64-битный тип, придется воспользоваться типом <code>int64_t</code>.</details></p>
</li>
<li>
<p>При прочих равных, используйте преинкремент <code>++i</code>, а не постинкремент <code>i++</code>. Это полезная привычка. В случае int'ов это все равно, но если у вас будет в коде сложный итератор, то в процессе постинкремента создается его копия в памяти, что может создать вам неожиданные тормоза и повышенное использование памяти, а догадаться о том, что вся проблема — в коротком выражении <code>it++</code> — будет сложно.</p>
</li>
<li>
<p><code>main</code> должен заканчиваться <code>return 0;</code>, в противном случае на некоторых компиляторах программа может завершиться с ненулевым кодом возврата, что в свою очередь приводит к Run-time error в тестирующей системе.</p>
</li>
<li>
<p>Вставляйте слово <code>const</code> везде, где только это возможно по смыслу. <details><summary>Подробнее</summary>
Если какая-то переменная по сути меняться в функции не должна, она должна быть <code>const</code>. Если метод класса не меняет при вызове содержимое класса, он должен быть <code>const</code>-методом. Таким образом вы обезопасите себя от многих глупых ошибок: они отловятся еще на этапе компиляции.</p>
<p>Если у вас из-за того, что вы где-то поставили в правильном месте <code>const</code>, не компилируется код, то <code>const</code> выполнил свою главную задачу. Тогда надо не его убирать, а найти и исправить проблему в другом месте: вы где-то еще забыли поставить <code>const</code> или изменяете переменную, которую не собирались изменять. Надо в этом разобраться, доставить <code>const</code> туда, где он еще нужен, а не удалять там, где он вам «мешает».</details></p>
</li>
<li>
<p>Используйте везде в программе индексацию с нуля. <details><summary>Подробнее</summary>
Если какие-то входные или выходные данные в задаче используют индексацию с единицы, лучше в функции ввода, соответственно вывода, переведите индексацию из одной системы в другую, а везде внутри программы, помимо функций ввода и вывода пользуйтесь индексацией с нуля. Весь язык C++ так спроектирован, что индексация с нуля гораздо удобнее, а как только вы начинаете использовать индексацию с единицы, становится неудобно, появляются вычитания единицы из переменных по всему коду и т.д. </details></p>
</li>
<li>
<p>Задумывайтесь о переполнениях типов. Если у вас есть две переменные типа <code>int</code>, значение каждой равно миллиону, и вы их перемножаете, то тип переполнится (максимальное значение — \(2^{31} - 1\)), и вы получите неправильный результат. Необходимо перед перемножением привести обе переменные к 64-битному типу <code>int64_t</code>. Если у вас есть две <code>int</code> переменные со значением два миллиарда и вы их складываете, — тоже произойдет переполнение, тоже нужно предварительно приводить к <code>int64_t</code>.</p>
</li>
<li>
<p>Не вычитайте никогда просто так ничего из <code>container.size()</code>, где <code>container</code> —  какой-нибудь контейнер из STL. <details><summary> Подробнее </summary></p>
<p>Например, <code>vector.size()</code> возвращает беззнаковый <code>size_t</code> (который обычно просто синоним для <code>unsigned long</code>), и если вы будете из него вычитать, то можете легко получить переполнение. Например, если вектор пустой, а вы вычитаете единицу, чтобы узнать последний элемент, или вектор состоит только из одного элемента, а вы вычитаете 2, чтобы узнать предпоследний элемент, и т.д. Всегда приводите результат вызова <code>size()</code> к int'у, если вам совершенно необходимо вычесть из <code>size()</code>, либо постарайтесь переписать сравнение без операции вычитания. При этом в самом распространенном случае,
когда вам нужно написать цикл <code>for</code>, проходящий по всем элементам, кроме, скажем, последних десяти, надо просто писать не так</p>
<pre><code class="language-C++">// Wrong! If container.size() &lt; 10, you'll get an infinite cycle.
// This code won't compile with the -Werror flag.
for (int index = 0; index &lt; container.size() - 10; ++index) {
    ...
}
</code></pre>
<p>В этом цикле, если, к примеру, <code>container.size() == 5</code>, то вы получаете реально цикл</p>
<pre><code class="language-C++">// Note that 4294967291 &gt; MAX_INT, so the cycle is infinite
for (int index = 0; index &lt; 4294967291; ++index) {
    ...
}
</code></pre>
<p>А пишите лучше всегда так</p>
<pre><code class="language-C++">// Correct: size_t and adding instead of subtracting
for (size_t index = 0; index + 10 &lt; container.size(); ++index) {
    ...
}
</code></pre>
<p>ну или хотя бы так</p>
<pre><code class="language-C++">// Correct: casted to int
for (int index = 0; index &lt; static_cast&lt;int&gt;(container.size()) - 10; ++index) {
    ...
}
</code></pre>
<p>Соответственно, если вам нужно вызвать функцию, в которую вы должны передать индекс первого и последнего элемента вектора, то делайте это так:</p>
<pre><code class="language-C++">SomeFunction(0, static_cast&lt;int&gt;(container.size()) - 1)
</code></pre>
<p>По-хорошему, здесь надо бы еще проверять, что в контейнере что-то есть, но к int'у приводить надо в любом случае, иначе появляются неочевидные баги. </details></p>
</li>
<li>
<p>Не пользуйтесь макросами для определения констант. <details><summary>Подробнее</summary></p>
<p>Макросы — это очень опасная и неудобная вещь. Их раскрывает специальный препроцессор, который начинает работать еще до компилятора C++, и он ничего не знает о самом языке. Все конструкции раскрываются буквально. В связи с этим есть множество возможных неочевидных побочных эффектов, а у компилятора нет возможности выполнить проверку типов, константность и т.д. Читайте более подробно об этом в книге Майерса «Effective C++».</p>
<p>Итак, неправильный вариант:</p>
<pre><code class="language-C++">#define MAX_LENGTH 100000  // Wrong! Don't use macros!
</code></pre>
<p>Правильный вариант:</p>
<pre><code class="language-C++">constexpr int kMaxLegth = 100000;  // Correct
</code></pre>
</details>
</li>
<li>
<p><a name="input_params"></a> Входные параметры передавайте в функцию по константной ссылке; по ссылке — чтобы они лишний раз не копировались, по константной — чтобы вы не могли их случайно изменить. <strong>Не забывайте про const!</strong> Выходные параметры передавайте в функции по указателю — чтобы вы могли их изменить; по указателю, а не по ссылке, — чтобы вы могли в месте вызова отличить входные параметры от выходных по амперсанду перед именем переменной. Размещайте входные параметры перед выходными в списке параметров функции или метода.
Аргументы примитивных типов следует передавать в функции по-другому. Входные параметры типов <code>int</code>, <code>char</code>, <code>bool</code>, <code>double</code> передавайте по значению. Они будут копироваться, но это так же почти бесплатно, как и в случае ссылок или указателей. При этом вы не сможете их изменить изнутри функции, что и нужно, т.к. это входные параметры. Если вам нужны эти типы как выходные параметры функции, лучше передавайте их по ссылке, т.к. иначе легко внутри функции перепутать указатель на переменную с самой переменной, и сделать совсем не то, что вы собирались. </p>
<details><summary>Примеры:</summary>
<pre><code class="language-C++">void Input(std::vector&lt;point&gt;* sequence, int&amp; points_to_cover);

void FindMaximumsInSlidingWindow(
    const std::vector&lt;int&gt;&amp; sequence, 
    const std::string&amp; shifts, 
    vector&lt;int&gt;* maximums);

double FindMinimumCoveringCircleRadius(
    const std::vector&lt;point&gt;&amp; points, 
    int points_to_cover);
</code></pre>
<p>Примеры вызовов:</p>
<pre><code class="language-C++">std::vector&lt;int&gt; sequence;
int points_to_cover;
Input(&amp;sequence, points_to_cover);
...
...
std::vector&lt;int&gt; sequence;
std::string shifts;
Input(&amp;sequence, &amp;shifts);
std::vector&lt;int&gt; maximums;
FindMaximumsInSlidingWindow(sequence, shifts, &amp;maximums);
...
...
double min_radius = FindMinimumCoveringRadius(points, points_to_cover);
</code></pre>
<p>Обратите внимание на амперсанды &amp; перед переменными, в которые записывается результат вызова функции.
Если функция возвращает одну величину, пусть она делает это по значению. Это столь же быстро, зато удобнее в месте вызова.
Пример:</p>
<pre><code class="language-C++">std::vector&lt;int&gt; ReadNumbers(std::istream&amp; input_stream = std::cin) {
    size_t sequence_length;
    input_stream &gt;&gt; sequence_length;
    std::vector&lt;int&gt; numbers(sequence_length);
    for (size_t i = 0; i &lt; numbers.size(); ++i) {
        input_stream &gt;&gt; numbers[i];
    }
    return numbers;
}

int main() {
    std::vector&lt;int&gt; first_sequence = ReadNumbers();
    std::vector&lt;int&gt; second_sequence = ReadNumbers();
    ...
}
</code></pre>
<p>Лишнего копирования в этом месте не возникнет. Дело в том, что эта операция настолько часто встречается, что компиляторы научились ее распознавать и генерировать эффективный код для нее. Технология называется return value optimization, известна также под своей аббревиатурой RVO. Можно и следует по умолчанию считать, что она есть и исправно работает, и писать код так, чтобы им было удобнее пользоваться. Чтобы узнать об этом более подробно, поищите в вашем любимом поисковике ее описание по названию.
Если переданный на вход параметр для выполнения алгоритма необходимо изменять, — это не означает, что параметр автоматически становится выходным параметром. Если целью алгоритма не является менять входной параметр, то изменять этот параметр функция не должна: пользователь алгоритма этого не ожидает, и будет очень не рад такому побочному эффекту. Кроме того, если просто передать параметр по ссылке и поменять его внутри, то пользователь даже не будет догадываться о том, что переданные им данные будут изменены. Появляющиеся вследствие таких побочных эффектов баги очень тяжело искать. Соответственно, в таких ситуациях есть два решения: передавать параметр по значению или передавать как обычно ко константной ссылке, а внутри функции копировать и изменять уже копию. Первый вариант (передавать по значению) обычно предпочтителен. Т.к. объект передается по значению, его можно менять внутри функции в процессе работы алгоритма (например, сортировать, если это вектор), при этом объект не изменится в месте вызова функции. При копировании аргумента, переданного по константной ссылке, в функции появляется два одинаковых по смыслу объекта, что может привести к путанице и использованию одного из них вместо другого, кроме того, копировать приходится вручную, тогда как при передаче объекта по значению копия делается автоматически, без написания дополнительного кода.
Пример:</p>
<pre><code class="language-C++">std::vector&lt;int&gt; Unique(std::vector&lt;int&gt; numbers) {
    // here we sort a copy of given numbers,
    // so that the user does not lose his data
    std::sort(numbers.begin(), numbers.end());
    numbers.erase(
        std::unique(numbers.begin(), numbers.end()),
        numbers.end());
    return numbers;
}
</code></pre>
</details>
</li>
<li>
<p>Разделяйте использование <code>class</code> и <code>struct</code>: классом должна быть любая сущность, которая содержит в себе логику, тогда как структура — это набор данных, объединенных в один объект. В классе все переменные-члены должны быть приватными, для доступа к ним делайте аксессоры, в структуре все переменные должны быть публичными, нетривиальных методов быть не должно.</p>
<details><summary>Пример</summary>
<pre><code class="language-C++">struct Point {
    double x, y;
};

// Compares first by x-coordinate, then by y-coordinate
bool operator &lt; (const Point&amp; first, const Point&amp; second) {
    if (first.x != second.x) {
        return first.x &lt; second.x;
    }
    return first.y &lt; second.y;
}

class Path {
public:
    Path(double time, double average_speed)
        : time_(time), average_speed_(average_speed)
    {}
    
    double Time() const {
        return time_;
    }
    
    double AverageSpeed() const {
        return average_speed_;
    }
    
    double Distance() const {
        return time_ * average_speed_;
    }

private:
    double time_;
    double average_speed_;
};
</code></pre>
<p>От структуры точки нам ничего не требуется, поэтому она состоит только из двух публичных полей. Метод <code>compare</code> добавлять нельзя, задача сравнения решается определением внешнего оператора &lt;. Если нужно, например, запретить изменять координаты (устанавливать их только при создании точки), то ее нужно делать классом с двумя get-аксессорами.
В классе <code>Path</code> хранится две величины, а получать требуется три. Если бы <code>time</code> и <code>averageSpeed</code> были публичными переменными, то доступ к значениям скорости и времени происходил бы как <code>path.time</code> и <code>path.averageSpeed</code>, а доступ к пройденному расстоянию — как <code>path.distance()</code>. Для нахождения расстояния приходится добавлять скобки, то есть всегда приходится помнить о том, что расстояние — это метод, а время и скорость — переменные. Если по какой-то причине (например, недостаточная точность) в будущем хранимые переменные нужно будет поменять и перейти к системе (время, расстояние), то в нашем случае с приватными переменными лишь изменится реализация методов, сохранив интерфейс класса. В случае же с публичными переменными придется изменять интерфейс класса, что немедленно влечет изменение всего кода, который его использует. Хранить все три величины переменными категорически нельзя: если время было равно 1, то действие <code>path.time = 0.0</code> нарушит инвариант <code>time * speed == distance</code>, что приведет к совершенно непредсказуемым последствиям.
Итак, если вам нужно хранить данные под общим именем, вам подойдет структура; во всех остальных случаях создавайте полноценный класс только с приватными переменные-членами.</details></p>
</li>
<li>
<p>Старайтесь не использовать по возможности динамическое выделение памяти (с помощью <code>new</code> и <code>malloc</code>): <details><summary>Почему</summary>
если вы будете его использовать, вам необходимо будет заботиться и об «уборке мусора», т.е. освобождении памяти. Правильный, безопасный способ это делать — не очень простой и не входит в материалы курса. Кроме того, вызов <code>new</code> довольно медленный, поэтому если очень много раз это сделать, то можете не влезть в Time limit. Если вам интересно, как правильно управлять динамической памятью, читайте книгу Майерса «Effective C++» или наберите в поисковике «RAII».</details></p>
</li>
<li>
<p>При использовании <code>vector</code> имейте в виду, что у него есть удобные методы: различные конструкторы, позволяющие задать размер и значение элемента вектора по умолчанию, операторы присваивания, сравнения (лексикографического) и оператор <code>swap</code>. <details><summary>Примеры:</summary></p>
<p>Создание двумерного вектора размером <code>rows * columns</code>, заполненного значением 100:</p>
<pre><code class="language-C++">std::vector&lt; vector&lt;int&gt; &gt; cache(
    rows,
    std::vector&lt;int&gt;(columns, 100));
</code></pre>
<p>Перестановка двух векторов местами без копирования всего содержимого:</p>
<pre><code class="language-C++">std::vector&lt;int&gt; first(1000000, 1);
std::vector&lt;int&gt; second(2000000, 2);
first.swap(second);
</code></pre>
<p>Здесь меняются местами реально два внутренних указателя <code>int*</code>, что значительно эффективнее, чем копирование векторов целиком, особенно если они большого размера.</details></p>
</li>
<li>
<p>Обратите внимание, что для взятия модуля вещественного числа (<code>float</code>, <code>double</code>) необходимо пользоваться функцией <code>fabs</code>, а не <code>abs</code>. При этом в Microsoft Visual Studio сделана перегрузка <code>abs</code>, которая работает и для вещественных чисел даже если вы не подключили заголовочный файл с ней напрямую. Однако на сервере при этом будет <code>abs(-2.75) != 2.75</code>.</p>
<p>В общем же случае стоит отметить, что в <code>c++</code> существует 2 версии <code>abs</code>:</p>
<ul>
<li>в <code>cmath</code>, определенная для вещественных чисел (<code>float</code>, <code>double</code> и <code>long double</code>).</li>
<li>в <code>cstdlib</code>, определенная для целых чисел (<code>int</code>, <code>long</code> и <code>long long</code>).</li>
</ul>
<p>Распространенная ошибка состоит в том, что подключается <code>cmath</code> и используется <code>abs</code> оттуда, что приводит к приведению целых типов в <code>double</code>, что в свою очередь может приводить к ошибкам округления при вызове <code>abs(long long)</code>.</p>
<p>Поэтому общее правило следующее:</p>
<ul>
<li>для взятия модуля <strong>вещественного</strong> числа необходимо подключить <code>cmath</code> и использовать <code>fabs</code>.</li>
<li>для взятия модуля <strong>целого</strong> числа необходимо подключить <code>cstdlib</code> и использовать <code>abs</code>.</li>
</ul>
</li>
<li>
<p>Если вы пользуетесь новым стандартом <code>c++11(c++0x)</code>, то для генерации (псевдо)случайных чисел рекомендуется использовать заголовок <code>random</code> с генератором псевдослучайных чисел <code>std::mt19937</code> и распределениями:</p>
<pre><code class="language-C++">std::uniform_int_distribution
std::uniform_real_distribution
</code></pre>
<p>и другими, если понадобятся. <details><summary>Подробнее</summary>
В противном случае, имейте в виду, что значение <code>RAND_MAX</code> — ограничения сверху на значения, выдаваемые функцией <code>rand()</code>,— отличаются в разных компиляторах. Тщательно изучайте, каково значение компилятора в вашем компиляторе, а каково — на компиляторе в автоматической системе (компилятор вы выбираете при сдаче задания). Подходит ли вам такое ограничение сверху, или нужно построить на базе функции <code>rand()</code> алгоритм, позволяющий возвращать случайные числа, равномерно распределенные в более широком диапазоне, чем <code>[0, RAND_MAX - 1]</code>?
При использовании схемы, предложенной новым стандартом <code>c++11|(c++0x)</code>, следует обратить внимание на то, где создавать генератор. Каждый алгоритм должен использовать собственный генератор, чтобы добиться независимой работы всех алгоритмов. Например, два алгоритма, использующих случайность, должны работать одинаково, вне зависимости от порядка их вызовов. Такой независимости сложно добиться при использовании функции <code>rand()</code>. 
Например, если вы хотите реализовать рандомизированный алгоритм сортировки, то нужно создать генератор внутри внешней функции, которую и будет вызывать пользователь, и передать его во внутреннюю, где будет реализована вся логика сортировки:</p>
<pre><code class="language-C++">#include &lt;random&gt;

template&lt;class Iterator&gt;
void Sort(Iterator begin, Iterator end) {
    std::mt19937 generator;
    QuickSort(begin, end, generator);
}
template&lt;class Iterator, class RandomGenerator&gt;
void QuickSort(Iterator begin, Iterator end, RandomGenerator&amp; generator) {
    ...
}
</code></pre>
</details>
</li>
<li>
<p>В большинстве случаев нельзя сравнивать числа типа <code>float</code> и <code>double</code> просто операторами &lt;, &gt;, &lt;=, &gt;=, ==: <details><summary>почему</summary>
при вычислениях в вещественных типах накапливается погрешность, вследствие чего равные по сути числа, вычисленные с помощью разной последовательности действий, могут получить различные значения в типах <code>float</code> и <code>double</code>, и даже <code>a &lt; b</code> может измениться на <code>b &lt; a</code>. Погрешность вычислений можно оценить, используя точные знания о том, как именно выполняются арифметические операции, а также как происходят вычисления в используемых вами функциях. Обычно делать этого точно не нужно, т.к. точность типа <code>double</code> позволяет хранить 15-16 знаков, а требуемая в задаче точность обычно порядка \(10^{-6}\) или \(10^{-9}\), но не меньше. Однако для того, чтобы корректно сравнивать числа, следует использовать порог сравнения. Примеры:</p>
<pre><code class="language-C++">const double COMPARISON_THRESHOLD = 1e-8;

bool Less(double first, double second) {
    return first &lt; second - COMPARISON_THRESHOLD;
}

bool LessOrEqual(double first, double second) {
    return first &lt; second + COMPARISON_THRESHOLD;
}

bool Equal(double first, double second) {
    return fabs(first - second) &lt; COMPARISON_THRESHOLD;
}
</code></pre>
</details>
</li>
<li>
<p>Для своих типов (классов, структур), если объекты типа необходимо сравнивать между собой, реализуйте всегда <code>operator&lt;</code> и не реализуйте остальные операторы сравнения (<code>operator&lt;=, operator&gt;, operator&gt;=</code>): <details><summary>почему</summary>
через <code>operator&lt;</code> выражаются все остальные, и общепринятая конвенция — реализовывать только сравнение на «меньше». В противном случае, дублируется код, а работа различных операторов может оказаться несогласованной. Точно так же, общая конвенция, — что сортировка объектов по умолчанию делается по возрастанию, и в качестве компаратора передается функция сравнения на «меньше». Это правило необходимо соблюдать, чтобы вашу программу было легко понимать другим программистам.</details></p>
</li>
<li>
<p>Не используйте <code>std::pair</code> (за исключением случая, описанного ниже). <details><summary>Подробнее:</summary>
Причина в том, что в месте использования объекта <code>pair</code> невозможно понять, что кроется за полем <code>first</code>, а что — за полем <code>second</code>. Это абстрактные названия, которые могут означать что угодно, а в месте использования никаких указаний на это нет. Даже если в месте определения переменной указать, что в ней хранится в <code>first</code> и <code>second</code>, при чтении придется постоянно возвращаться к месту определения переменной, чтобы разобраться в коде и убедиться, в частности, что <code>first</code> и <code>second</code> нигде не перепутаны местами — часто встречающаяся ошибка! 
Исключением являются небольшие участки кода (помещающиеся на один экран), в рамках которых создается из имеющихся объектов <code>pair</code>, далее удобно используется для какой-нибудь операции (например, сортировка), и затем все <code>pair</code> обратно «расшифровываются» в новые объекты и более не используются. Это может быть удобно для сортировки по вторичному параметру, т.к. для <code>pair</code> есть оператор сравнения по умолчанию, который сравнивает сначала по <code>first</code>, затем по <code>second</code>. При этом код легко понять, т.к. <code>pair</code> определен и используется в одном очень локальном куске кода, который можно охватить взглядом целиком.</details></p>
</li>
</ol>
<h2 id="Организация-кода"><a class="header" href="#Организация-кода">Организация кода</a></h2>
<p>Как и любая система, код при разрастании становится все более путаным и сложным. Однако есть способы перевести эту сложность преимущественно в его размер, сохраняя логику ясной и прозрачной. Помогает в этом грамотное структурирование: что может быть классом, что должна делать функция, где что должно объявляться. Оно же позволяет удобно осуществить повторное использование нужных участков кода.</p>
<ol>
<li>
<p>У каждой переменной должна быть одна-единственная явная цель. Никогда не создавайте переменных <code>tmp</code>, выполняющих несколько разных вспомогательных функций во всем коде. Используйте переменную только с одной целью. Переменные, в названии которых используется <code>tmp</code> или <code>temp</code>, почти всегда либо бессмысленные и ненужные, либо неправильно названы.</p>
</li>
<li>
<p>Объявляйте переменные как можно ближе к месту их первого использования. Старайтесь сразу же инициализировать переменные. Если переменная используется только внутри функции, она должна быть локальной для функции. Если только внутри цикла, она должна быть локальной для цикла. Никогда не делайте глобальных переменных. Локальные переменные блока предпочтительнее по сравнению с локальными переменными функции, локальные переменные функции — по сравнению с переменными-членами класса, а последние — по сравнению с глобальными переменными. Стремитесь сократить «время жизни» каждой переменной: чем меньше время жизни переменных, тем меньше переменных приходится одновременно держать в голове при чтении и написании кода. Исследования показывают, что человек может эффективно держать в памяти не более 5-7 переменных одновременно. Большее количество неизбежно приводит к ошибкам.</p>
</li>
<li>
<p>Разделяйте программу на ввод, решение и вывод, это делает ваш код более модульным.
Способы ввода и вывода часто меняются. У нас используются стандартные потоки и определенный описанный формат, в следующий раз те же данные могут быть записаны в файле или в базе данных в другом формате, затем они же могут поставляться уже в виде переменных в более сложной программе, которая использует ваш алгоритм в качестве подпрограммы.
Записывайте вход в отдельные переменные и результат работы — в отдельные. Для их заполнения и вывода напишите отдельные функции. В частности, ваш код становится легче тестируемым, что является важным свойством. Вы можете написать альтернативное решение и сравнить его с вашим, можете запустить стресс-тест.
Вообще это две принципиально разные области ответственности: ввод-вывод и преобразование данных. Не смешивайте в одном классе или функции несколько разных областей ответственности: один класс отвечает ровно за одну область. Иначе он разрастается, становится слишком сложным, а две разные области ответственности начинают быть слишком сильно связанными. Это плохо, потому что чем более независимы разные части программы, тем меньше поводов для ошибок и тем проще тестировать части программы по отдельности.</p>
</li>
<li>
<p>Никогда не используйте «магические константы» в коде. Если у вас где-то в коде встречаются, например, <code>'a'</code> и <code>'z'</code>, означающие минимальный и максимальный символ алфавита, то их надо заменить на именованные константы. Например так:</p>
<pre><code class="language-C++">const char MIN_LETTER = 'a';
const char MAX_LETTER = 'z';
...

for (char letter = MIN_LETTER; letter &lt;= MAX_LETTER; ++letter) {
    ...
}
...
</code></pre>
</li>
<li>
<p>Пишите комментарии только по делу. В идеальном случае лучше обходиться вообще без них — ваш код прокомментирует сам себя. Конечно, так редко удается, поэтому комментарии к классам и функциям бывают полезными.
Не нужно оправдывать плохое имя (см. следующий раздел) подробным комментарием. Если у вас встречается объявление вида</p>
<pre><code class="language-C++">int n;  // number of balls in the bucket
</code></pre>
<p>то нужно заменить его на <code>int number_of_balls;</code> или <code>int numBallsInBucket;</code> в зависимости от принятого стиля, от того, бывают ли шары не в корзине, и от контекста.
Писать комментарий следует <strong>над</strong> тем, к чему он относится. Комментарии в конце строки значительно удлиняют ее, поэтому ухудшают читаемость. При этом желательно, чтобы строка влезала в 100 символов, а зачастую бывает жесткое ограничение по длине строки (как в нашей системе проверки). Если вы все же пользуетесь комментарием в конце строки, то отделяйте его двумя пробелами от кода.
Комментарии к функции должны быть написаны рядом с интерфейсом, а не с реализацией, если они разделены: пользователь будет в первую очередь смотреть на интерфейс, к тому же реализация сторонних библиотек может быть вовсе недоступной. То же самое относится и к классам: комментарии к классу и к его методам должны быть в интерфейсе класса, а не в реализации.
Если вы решили снабдить свой код подробными комментариями, указывайте в них то, что будет интересно читающему. Для класса это описание того, для чего класс нужен, как им пользоваться. Для функции и метода — что они делают, что возвращают, что принимают на вход, какие исключения могут бросать.
Вот пример хорошего комментария к функции.</p>
<pre><code class="language-C++">/* Applies per symbol transformation to string.
* input[i] is transformed into transform[input[i]].
* If transform map doesn't contain input[i] and defaultSymbol isn't null,
*   input[i] is transformed to defaultSymbol.
* If transform map doesn't contain input[i] and defaultSymbol == 0,
*   function throws TransformError.
*/
string TransformString(
    const string&amp; input,
    const map&lt;char, char&gt;&amp; transform,
    const char defaultSymbol);
</code></pre>
</li>
</ol>
<h3 id="Имена"><a class="header" href="#Имена">Имена</a></h3>
<p>У каждой создаваемой сущности в коде есть имя. Сперва автор, а впоследствии, и все читающие код ассоциируют имена с сущностями, которые они обозначают. Чтобы в каждый момент точно понимать, что в переменной хранится, чтобы быть уверенным в том, что вызов функция вернет ожидаемое значение, имена нужно давать осмысленные и грамотно определенные.</p>
<ol>
<li>
<p>Имена переменных должны быть длинными и понятными. Каждый раз, когда вы пишете одно-двух-буквенное название переменной или используете что-то вроде cur, должно возникать неприятное чувство. Единственное место, где можно позволить себе однобуквенные переменные, — в качестве счетчика в очень коротком for'е без вложенных циклов. И то, у вас должны быть серьезные опасения, когда вы это делаете, вы должны делать это осознанно. Иначе можно легко допустить ошибку с индексами, например перепутать i с j, что происходит постоянно, если называть так переменные. Искать такую ошибку вы будете несколько часов или дней. Даже если в описании задачи есть названия R и L, это не значит, что в программе нужно их так называть. Стиль математического текста очень сильно отличается от стиля кода программы. В математическом тексте есть очень много слов, описывающих формулы и то, что в них происходит. В самих формулах ценится краткость. В коде же наоборот, слов, описывающих происходящее, практически нет. Код должен описывать сам себя, названиями переменных, методов и классов. Поэтому названия должны быть очень прозрачными. Не должно быть нужно возвращаться и смотреть вверх в объявление переменной или смотреть на ее инициализацию, чтобы понять, что она в себе содержит.
Никогда не называйте переменные <code>something1</code> и <code>something2</code>, так как очень легко ошибиться и попасть по соседней клавише, тем самым очень легко сделать баг, а искать его будет тяжело. Используйте <code>something_first</code> и <code>something_second</code> или что-нибудь еще. <em>Как выбрать понятное название переменной?</em> Сперва нужно описать переменную на английском (так чтобы из описания было понятно, что хранит переменная), а далее выбирать название исходя из соображений компромисса между длиной и понятностью. (3-5 слов в названии — это нормально). </p>
</li>
<li>
<p>Все, что относится к именам переменных, относится и к именам функций, классов и методов. Кроме того, в названиях методов (функций) обязательно должен быть глагол, описывающий действие, которое выполняет метод. Это действие должно быть одно. У каждой функции должна быть одна ясная цель. Если вы понимаете, что не можете придумать название функции без слова And (например, <code>ReadFromFileAndSort</code>), значит, функция выполняет две разные цели, и скорее всего, ее нужно разбить на несколько меньших функций (<code>ReadFromFile</code> и <code>Sort</code>), и из внешней вызывать подряд внутренние.</p>
</li>
<li>
<p>Не сокращайте слова в названиях. Это ухудшает читаемость кода, а также делает невозможным поиск по нему. Не нужно сокращать <code>index</code> до <code>ind</code> или <code>idx</code>, <code>current</code> — до <code>cur</code> и т.д. Единственное исключение — общепринятые сокращения типа <code>Http</code> и т.д.</p>
</li>
<li>
<p>Выделяйте названия приватных членов классов, это позволяет отличить их от аргументов методов. Наиболее распространенными способами являются подчеркивание в конце: <code>name_</code>, — или префикс <code>m_</code>: <code>m_name</code>. Начинать имя переменной с подчеркивания не принято; следует помнить о том, что имена, начинающиеся на два подчеркивания или подчеркивание и заглавную букву, зарезервированы стандартом, и использовать их нельзя.</p>
</li>
</ol>
<h2 id="Продвинутые-замечания"><a class="header" href="#Продвинутые-замечания">Продвинутые замечания</a></h2>
<ol>
<li>
<p>Не оптимизируйте преждевременно. Ваш алгоритм должен иметь правильную асимптотическую сложность, чтобы иметь шансы пройти в Time limit. Он должен правильно работать, чтобы не получить Wrong answer. Это два основных тезиса. Не нужно оптимизировать с целью ускорить программу в константу раз, если это хоть сколько-нибудь усложняет код. Старайтесь сделать свое изначальное решение максимально простым. Оптимизировать нужно только после того, как вы четко замерили время работы программы, убедились, что оно слишком большое, определили, какая именно функция создает узкое место. Даже суперпрофессионалы не берутся заранее предсказывать узкие места системы: в наше время, когда компиляторы умеют делать сумасшедшие оптимизации, это практически невозможно предугадать. Поэтому профессионалы и не пытаются делать это заранее и оптимизировать что-либо заранее. Сначала измерьте, найдите узкое место, а потом уже пытайтесь его оптимизировать. Все вышесказанное относится к выносу переменных из цикла для ускорения, к перебору не до n, а до n / 2 и т.д. — не нужно ничего из этого сделать. Напишите максимально простое решение, добейтесь правильной его работы, и если вдруг после этого оно окажется слишком медленным — только тогда оптимизируйте. Ваша задача в программах, которые вы пишете на этом курсе, — написать наиболее простой, понятный, читаемый и гибкий код, среди тех, которые проходят в ограничения по времени и памяти. Помните об этом и не оптимизируйте, жертвуя простотой и удобством.</p>
</li>
<li>
<p>Не выполняйте никакую сложную работу в конструкторе, также не обращайтесь в конструкторе к каким-либо внешним для программы объектам, таким как файловая система, стандартные потоки ввода и вывода, базы данных и т.д. В конструкторе должна быть только простейшая инициализация полей класса, автономная или в зависимости от параметров конструктора. Это связано с тестированием класса и гибкостью дизайна.
На самом деле, почти всегда класс, который легко тестировать, имеет гибкий дизайн и его удобно использовать, и наоборот. Если у класса в конструкторе
происходят какие-то сложные действия (обращение к файлу, базе данных или запуск сложного алгоритма), то его сложно протестировать. Чтобы протестировать класс в юнит-тесте, нужно для начала хотя бы создать экземпляр этого класса.
Если для этого требуется какой-то файл или база данных, то это уже получается сразу не юнит-тест, т.к. ему для работы нужны внешние данные, внешние объекты, что неудобно, в идеале тест должен быть изолирован от остальной системы для чистоты эксперимента. Подменить данные, лежащие в базе данных или в файле, существенно сложнее,  чем передать другие значения параметров в какую-то функцию. Для того, чтобы обойти использование файлов и баз данных, придется переделывать класс, в частности убирать у него из конструктора непосредственные обращения к файлам и базе данных. А если это делается не непосредственно в конструкторе этого класса, а в методах других классов, вызываемых в конструкторе, то придется выносить объекты этих классов наружу и подменять их.
Если внутри конструктора сложный алгоритм, то его тоже было бы неплохо протестировать, однако это уже становится невозможно, потому что как только мы захотим создать экземпляр класса, так сразу же вызовем конструктор, и там уже весь алгоритм выполнится, отдельные функции, которые он использует протестировать не получится. Если алгоритм работает неправильно, то к моменту создания объекта класса он будет находиться в некорректном состоянии, и тестировать его будет уже бессмысленно.
Иногда даже иметь в классе указатели на объекты других конкретных классов и создавать их в конструкторе неправильно. Например, если класс, выполняющий какой-то конкретный алгоритм, имеет у себя указатель на объект для работы с базой данных, который в конструкторе инициализируется для обращения к конкретной базе, то такой класс тоже невозможно протестировать по вышеописанным причинам.
На самом деле, нашему алгоритмическому классу нужны от класса, работающего с базой данных, лишь конкретные данные, которые тот берет из базы данных,
и скорее всего далеко не все данные, которые есть в базе. Поэтому имеет смысл написать «обертку» вокруг класса, работающего с базой, которая будет обращаться к базе и доставать произвольные данные с помощью внутреннего класса, работающего непосредственно с базой, а наружу отдавать
только те куски данных, которые имеют смысл для алгоритмического класса. А для того, чтобы впоследствии можно было работать не только с базой данных, но те же данные брать из файла или откуда-то из памяти другого объекта, нужно сделать общий интерфейс для классов, поставляющих данные алгоритмическому, и конкретный класс, берущий данные именно из базы, породить от этого интерфейса. Под интерфейсом в данном случае имеется в виду класс с чисто виртуальными методами, который определяет интерфейс всех своих потомков, но инстанцировать который невозможно. Далее, в конструктор алгоритмического класса передавать уже указатель на такой интерфейс, а не указатель на конкретный класс для работы с базой данных, и в конструкторе просто копировать этот указатель
во внутреннюю переменную для будущего использования. В таком случае при тестировании можно будет создать mock класса, достающего данные, реализовав этот интерфейс. Наш mock будет «подсовывать» алгоритмическому классу те данные, которые мы хотим, то есть абсолютно любые, что и нужно для полного тестирования. Соответственно, мы сможем проверить реакцию на разные крайние случаи, запустить стресс-тест, понять, какие ограничения на данные должен проверять на входе алгоритмический класс. 
Нам не придется создавать специальные базы данных для тестирования с подмененными данными, мы сможем генерировать эти данные прямо в памяти, в огромных количествах, сможем выполнить хоть 100000 тестов, если каждый из них выполняется быстро. С базами данных это не получится, потому что, во-первых, один тест, обращающийся в процессе к базе данных, уже в любом случае будет занимать существенное время, а во-вторых потому что не получится создать 100000
различных таблиц.</p>
<p>Более подробное описание, примеры и другие советы для написания хорошо тестируемых классов см. <a href="http://misko.hevery.com/attachments/Guide-Writing%20Testable%20Code.pdf">здесь</a>.</p>
</li>
</ol>
<p align="center">
  <img src="images/styleguide_cat.jpg" />
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="Как-сдавать-домашние-задания"><a class="header" href="#Как-сдавать-домашние-задания">Как сдавать домашние задания</a></h1>
<p>На курсе есть несколько видов активностей, которые влияют на вашу оценку:</p>
<ul>
<li>задачи, сданные в <a href="https://contest.yandex.ru">Контест</a>, в том числе задачи, разобранные на семинарах,</li>
<li>задачи, по которым нужно проходить код-ревью,</li>
<li>теоретические домашние задания.</li>
</ul>
<h2 id="Домашние-задания-в-контесте"><a class="header" href="#Домашние-задания-в-контесте">Домашние задания в контесте</a></h2>
<p>Код программ, которые вы будете сдавать в рамках нашего курса, будет проверяться автоматически в системе <a href="https://contest.yandex.ru">Яндекс.Контест</a>.</p>
<h3 id="Требования-к-вводу-выводу"><a class="header" href="#Требования-к-вводу-выводу">Требования к вводу-выводу</a></h3>
<p>Программа должна читать из стандартного входа и писать в стандартный выход. Входной формат гарантируется: будет так, как описано в условии. Строго придерживайтесь выходного формата. Лишние пробелы и лишние переводы строк — не страшно, а вот пропустить пробел, вывести не в том порядке, пропустить перевод строки или вывести что-то лишнее — будет являться ошибкой.</p>
<h3 id="Вердикты-по-задаче"><a class="header" href="#Вердикты-по-задаче">Вердикты по задаче</a></h3>
<p>Система выдает один из следующих результатов на каждый запуск.</p>
<ul>
<li><strong>OK</strong> — задача прошла успешно.</li>
<li><strong>PCF</strong> — Precompile check failed — code style violation, вы нарушили какие-то из требований по оформлению кода. Чтобы узнать, какие именно, нажмите на ссылку отчет и почитайте. За эту ошибку не снимаются баллы. Также вы можете получить такую ошибку, если использовали при реализации какую-нибудь стандартную структуру данных или какой-нибудь стандартный алгоритм из библиотеки STL, который в данной задаче было использовать запрещено в условии задачи.</li>
<li><strong>CE</strong> — Compilation Error — ваша программа не компилируется на сервере. Чтобы узнать, почему, нажмите на ссылку «отчет» (она появляется при наведении курсора на строку посылки) и посмотрите, какие ошибки нашел компилятор.</li>
<li><strong>WA</strong> — Wrong Answer — на некотором тесте программа выдала неверный ответ. Вам не предоставляется возможность увидеть, что это был за тест. Внимательно посмотрите на ограничения в задаче, попробуйте придумать свой тест, на котором ответ будет неправильный. <strong>-1 балл</strong>.</li>
<li><strong>PE</strong> — Presentation Error — ошибка представления. Например, просили вывести число, а выведена строка. В этом случае вы можете получить <strong>Wrong Answer</strong> либо <strong>Presentation error</strong>, это не гарантируется заранее. <strong>-1 балл</strong>.</li>
<li><strong>TL</strong> — Time Limit exceeded — ваша программа работает слишком долго. Значит, у вас неправильное асимптотически решение, так как таймлимиты будут выставляться в 2–3 раза больше, чем время работы авторского решения на максимальном тесте, и этого должно хватать любому правильному решению. <strong>-2 балла</strong>.</li>
<li><strong>ML</strong> — Memory Limit exceeded — ваша программа использует слишком много памяти. <strong>-2 балла</strong>.</li>
<li><strong>RE</strong> — Runtime Error — произошла ошибка выполнения. Неочевидные возможные причины: чтение из файла вместо стандартного ввода; запись в файл вместо стандартного вывода; переполнение стека. Очевидные причины: выход за границы массива, деление на ноль. <strong>-2 балла</strong>.</li>
</ul>
<p><strong>За тесты из условия баллы не снимаются.</strong></p>
<h3 id="Теоретические-домашние-задания"><a class="header" href="#Теоретические-домашние-задания">Теоретические домашние задания</a></h3>
<p>Тут всё просто — присылайте pdf файл с решением. Рукописные решения не принимаются, можно использовать <a href="https://www.overleaf.com/read/rrdzfpprjmpt">шаблон</a>. 
Можно присылать исправления ДО дедлайна.</p>
<h2 id="Ревью"><a class="header" href="#Ревью">Ревью</a></h2>
<p>Проверка задачи на ревью состоит из двух этапов:</p>
<ol>
<li>Проверка теоретического решения задачи</li>
<li>Проверка кода программы</li>
</ol>
<h3 id="Проверка-теоретического-решения"><a class="header" href="#Проверка-теоретического-решения">Проверка теоретического решения</a></h3>
<p>Присылайте pdf файл с описанием вашего решения:</p>
<ul>
<li>алгоритм решения</li>
<li>доказательство правильности алгоритма</li>
<li>временная сложность — асимптотика</li>
<li>затраты памяти — асимптотика</li>
</ul>
<p>Все пункты обязательны!
Если можете доказать, что быстрее невозможно или меньше памяти использовать невозможно, тоже пишите, это полезно. Рукописные решения не принимаются, можно использовать <a href="https://www.overleaf.com/read/rrdzfpprjmpt">шаблон</a>.</p>
<p>Ваше решение должно быть написано понятным русским языком, использовать (псевдо)код либо выражения в духе «этой переменной присваиваем то-то» не надо. Излишне подробно расписывать тоже не нужно: решение любой задачи укладывается на одну страницу A4, максимум полторы. <strong>Ссылаться на факты, доказанные на лекции, можно и нужно (т.е. не надо заново доказывать, какая сложность у вашей сортировки).</strong></p>
<h3 id="code-review"><a class="header" href="#code-review">Code Review</a></h3>
<p>После того как сдадите код в систему, нужно будет отправить его на проверку нам.
Подробнее о том, как сдавать задания на код-ревью можно посмотреть <a href="https://docs.google.com/document/d/1-Ju9byCX3aYSUTITntxiiTDlgSPxD1brNi1-HWCp6jM/edit">тут</a></p>
<p><strong>О сроках.</strong> На сдачу теории дается 1 неделя с момента выдачи задачи, и еще 3 недели на то, чтобы пройти все тесты в системе и прислать интерфейс работающей программы на ревью. Затем Code Review идет до тех пор, пока все замечания не будут исправлены, либо не закончится семестр. Рассчитывайте на то, что время ответа ревьюера в среднем составляет 5 рабочих дней, поэтому не затягивайте с отправкой кода и соблюдайте <a href="./styleguide.html">стайлгайд</a>.
Все дедлайны будут прописаны на странице курса в lms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-настроить-окружение-на-своем-компьютере"><a class="header" href="#Как-настроить-окружение-на-своем-компьютере">Как настроить окружение на своем компьютере</a></h1>
<h2 id="Введение"><a class="header" href="#Введение">Введение</a></h2>
<p>С недавнего времени на сервере используется новая схема тестирования решений, а точнее, отлавливается большее число ошибок за счет использования других ключей компиляции. Цель этой заметки — помочь вам получить такой же эффект на своей системе.</p>
<p>Помимо этого, описанные здесь рекомендации позволят вам организовать более качественное тестирование кода.</p>
<p>На сервере компилируется 2 варианта вашего решения, а именно:</p>
<pre><code class="language-bash">g++-8 solution.cpp -std=c++17 -O2 -Wall -Werror -Wsign-compare -o fast_solution
g++-8 solution.cpp -fsanitize=address,undefined -fno-sanitize-recover=all -std=c++17 -O2 -Wall -Werror -Wsign-compare -o debug_solution
</code></pre>
<p>Здесь стоит отметить следующее:</p>
<ol>
<li><code>-Wall</code> и <code>-Werror</code>. Первый флаг заставляет компилятор выдавать дополнительные предупреждения, второй — трактовать любое предупреждение как ошибку компиляции. Таким образом, ваш код не должен давать ни одного предупреждения.</li>
<li><code>-O2</code> включает оптимизации кода.</li>
<li><code>-std=c++17</code> нужен для использования стандарта <code>C++17</code>. Если вы не особо обращаете внимание на используемый стандарт, то можете продолжать это делать и писать, как раньше. Остальные могут использовать все фишки нового стандарта.</li>
</ol>
<p>Во втором случае решение компилируется с включенными <em>санитайзерами</em>. Любое обращение за пределы массива, знаковое переполнение целочисленных типов и любые подобные проявления некорректной работы с памятью и undefined behavior будут вызывать ошибку времени выполнения и приводить к вердикту Runtime Error на сервере, а не ситуации, когда ваша программа иногда работает, а иногда нет.</p>
<p>Обратите внимание, что <code>-fsanitize=address</code> также включает детектор утечек памяти. Поэтому, помимо контроля над тем, куда обращается ваша программа, на сервере также производится проверка, что в вашей программе нет утечек памяти (сделали <code>new</code> и не сделали <code>delete</code>). В подавляющем большинстве случаев вам вообще не нужно оперировать с динамической памятью вручную (например, для создания массивов используйте стандартные контейнеры вроде <code>std::vector</code>, которые правильно обращаются с памятью).</p>
<p>Поскольку санитайзеры вносят заметный оверхед в решение (значительно увеличивается потребляемая память и в несколько раз может возрасти время исполнения), то они используются только для запуска на маленьких тестах (обычно не более первых десяти в задаче), чтобы правильные решения не могли получить вердикты ML или TL.</p>
<h2 id="Примеры-кода"><a class="header" href="#Примеры-кода">Примеры кода</a></h2>
<p>Давайте рассмотрим на примерах, как работает компилятор с указанным выше набором флагов. В этом разделе приведены комментарии по поведению <code>gcc</code> и <code>clang</code> в linux с включенными санитайзерами. Про другие ОС см. секции ниже.</p>
<p>Здесь происходит знаковое переполнение при вычислении <code>BAD_MAX_INT</code>, что порождает соответствующее предупреждение. В десятой строке происходит сравнение <code>int</code> и <code>size_t</code>, что также порождает предупреждение. <strong>Никогда</strong> не игнорируйте это предупреждение: при таком сравнении <code>int</code> приводится к беззнаковому типу, таким образом, неравенство <code>-1 &gt; size_t</code> всегда выполнено. Этот код не компилируется с флагом <code>-Werror</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

const int BAD_MAX_INT = (1 &lt;&lt; 31) - 1;

int main() {
    size_t n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; data(n);
    for (int i = 0; i &lt; data.size(); ++i) {
        std::cin &gt;&gt; data[i];
    }
    return 0;
}
</code></pre>
<p>В этом примере происходит очевидный выход за пределы массива. Если заменить динамический массив на <code>std::vector</code>, произойдет то же самое. И <code>gcc</code>, и <code>clang</code> успешно отловят данную ошибку с включенными санитайзерами.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    size_t n;
    std::cin &gt;&gt; n;
    int *data = new int[n];
    for (size_t i = 0; i &lt; n; ++i) {
        std::cin &gt;&gt; data[i];
    }
    std::cout &lt;&lt; data[n] &lt;&lt; &quot;\n&quot;;
    delete[] data;
    return 0;
}
</code></pre>
<p>В этом примере есть утечка памяти (нет <code>delete[]</code>)</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    size_t n;
    std::cin &gt;&gt; n;
    int *data = new int[n];
    for (size_t i = 0; i &lt; n; ++i) {
        std::cin &gt;&gt; data[i];
    }
    return 0;
}
</code></pre>
<p>Здесь возникает <code>undefined behavior</code> при переполнении (введем <code>2000000000 2000000000</code>), который отловят и <code>clang</code> и <code>gcc</code> с включенным флагом <code>-fsanitize=undefined</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int a, b;
    std::cin &gt;&gt; a &gt;&gt; b;
    std::cout &lt;&lt; a + b &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<h2 id="Настройка-на-своей-системе"><a class="header" href="#Настройка-на-своей-системе">Настройка на своей системе</a></h2>
<p>Мы рекомендуем использовать среду Clion для разработки. Всем студентам ШАД предоставляется бесплатная лицензия, которую можно найти <a href="https://lk.yandexdataschool.ru/learning/useful">здесь</a>. Вы можете работать из любой ОС, однако добиться поведения, описанного выше, можно только
на Linux и Mac OS. Опыт показывает, что прохождение ШАДа с использованием Windows достаточно мучительно, поэтому лучше заранее озаботиться установкой Linux. Самый удобный вариант — развернуть VirtualBox. Если же у вас Windows 10, то еще одним вариантом будет установка <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a> и <a href="https://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-clion.html">его интеграция с Clion</a>.</p>
<p>Ниже приведена инструкция для Clion.</p>
<p>Создайте новый проект, зайдите в File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Cmake. Изначально там будет только один профиль Debug. Когда вы нажмете + добавится
профиль Release, который пригодится в дальнейшем. Добавьте еще один профиль, назовите его ASAN. В Cmake Options запишите</p>
<pre><code>-DCMAKE_BUILD_TYPE=ASAN
</code></pre>
<p>Отредактируйте ваш <code>CmakeLists.txt</code>. Он будет выглядеть примерно так:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.12)
project(my_project)

set(CMAKE_CXX_STANDARD 17)

set(CMAKE_CXX_FLAGS_ASAN &quot;-g -fsanitize=address,undefined -fno-sanitize-recover=all&quot;
        CACHE STRING &quot;Compiler flags in asan build&quot;
        FORCE)

add_executable(my_project main.cpp)
</code></pre>
<p>Теперь вы легко можете переключаться между разными видами сборок: Debug для пошагового дебага, Release для тестирования производительности, ASAN для запуска
с санитайзерами.</p>
<details><summary>Windows</summary>
<p>На Windows без использования WSL санитайзеры не работают. Вы точно так же можете использовать Clion, но поддержки asan там не будет (если только вы не настроили интеграцию с WSL, см. ссылки выше).</p>
<h3 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h3>
<p>В Visual Studio полный аналог санитайзеров получить не получится (а именно, undefined), но эмулировать <code>-fsanitize=address</code> более-менее можно.</p>
<p>Для начала снова рассмотрим код с предупреждениями:</p>
<p><img src="images/environment_windows_1.png" alt="img" /></p>
<p>Зайдем в Проект -&gt; Свойства. Дальше для всех конфигураций в свойствах конфигурации нужно выбрать следующий пункт:</p>
<p><img src="images/environment_windows_2.png" alt="img" /></p>
<p>Это аналог <code>-Werror</code> на сервере. Действительно, получаем ошибку компиляции:</p>
<p><img src="images/environment_windows_3.png" alt="img" /></p>
<p>То же самое и для конфигурации Release:</p>
<p><img src="images/environment_windows_4.png" alt="img" /></p>
<p>Рассмотрим теперь такой код:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    size_t n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; data(n);
    for (size_t i = 0; i &lt; n; ++i) {
        std::cin &gt;&gt; data[i];
    }
    std::cout &lt;&lt; data[n] &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<p>Тут есть очевидный выход за границы массива. В Visual Studio в Debug режиме полностью проверяются все операции со стандартными контейнерами. Таким образом, запуск этого кода в Release отработает успешно, а вот в Debug вы получите примерно такую ошибку:</p>
<p><img src="images/environment_windows_5.png" alt="img" /></p>
<p>К сожалению, если вы используете просто динамическую память (см. пример кода 2), то даже в Debug режиме все отработает успешно. Это еще один повод использовать стандартные контейнеры.</p>
<p>Рассмотрим теперь третий пример, в котором происходит утечка памяти. В Visual Studio вы можете дописать в начало кода строки:</p>
<pre><code class="language-cpp">#define _CRTDBG_MAP_ALLOC
#include &lt;stdlib.h&gt;
#include &lt;crtdbg.h&gt;
</code></pre>
<p>Перед выходом из программы (перед <code>return 0</code> в main например) добавьте строку</p>
<pre><code class="language-cpp">_CrtDumpMemoryLeaks();
</code></pre>
<p>Программа по-прежнему будет завершаться успешно, но в поток ошибок будет выведено следующее сообщение:</p>
<p><img src="images/environment_windows_6.png" alt="img" /></p>
<p>Проверим с <code>delete[]</code>:</p>
<p><img src="images/environment_windows_7.png" alt="img" /></p>
<p>Также обязательно запускайте ваше решение в конфигурации Release, потому что при этом включается <code>-O2</code>, что может приводить к другому поведению вашей программы (и на сервере тоже) в случае наличия в ней багов.</p>
</details>
<details><summary>Mac OS</summary>
<p>По сравнению с Linux, на маке необходимо произвести ряд дополнительных действий, чтобы получить такое же поведение. Для начала обязательно установите <code>gcc</code> из <code>brew</code>, никогда не используйте системный <code>gcc</code>. Выполните</p>
<pre><code class="language-bash">brew install gcc
</code></pre>
<p>Чтобы проверить, что gcc установился правильно, выполните (10 нужно заменить на версию gсс, установленную brew):</p>
<pre><code class="language-bash">g++-10 --version  # выведет полную версию g++
which g++-10  # выведет полный путь к компилятору, например /usr/local/bin/g++-10
</code></pre>
<p>Далее необходимо прописать путь к новому компилятору в настройках Clion. Для этого зайдите в File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Toolchains и в C++ compiler пропишите полный путь к компилятору.</p>
<p>Далее, <strong>обратите внимание</strong>, что по умолчанию под маком asan не включает проверку на утечки памяти. Чтобы этого избежать, добавьте строчку</p>
<pre><code class="language-bash">export ASAN_OPTIONS=detect_leaks=1
</code></pre>
<p>в файл </p>
<pre><code>~/.MacOSX/environment.plist
</code></pre>
<p>Иногда на маках при компиляции с asanом может выпадать большое количество ошибок, не связанных с вашим кодом. В этом случае попробуйте добавить флаг <code>-fsanitize-undefined-trap-on-error</code> для asan-сборки (переменная <code>CMAKE_CXX_FLAGS_ASAN</code> в <code>CmakeLists.txt</code>).</p>
</details>
<h2 id="Проверка-на-соответствие-стайлгайду-и-форматирование-кода"><a class="header" href="#Проверка-на-соответствие-стайлгайду-и-форматирование-кода">Проверка на соответствие стайлгайду и форматирование кода</a></h2>
<p>Инструкция ниже для Linux и Mac OS.</p>
<p>Вам понадобятся утилиты clang-format и clang-tidy, они обычно есть в стандартных репозиториях (<code>apt-get install</code> или <code>brew install</code>). Для clang-format вы можете взять конфиг <a href="https://gitlab.com/slon/shad-cpp0/raw/master/.clang-format">отсюда</a>, а для clang-tidy
<a href="https://gitlab.com/slon/shad-cpp0/raw/master/.clang-tidy">отсюда</a>.</p>
<p>Положите эти файлы в директорию с кодом или в домашнюю директорию. Для форматирования кода выполните</p>
<pre><code class="language-bash">clang-format -i main.cpp
</code></pre>
<p>Вы также можете настроить автоматическое форматирование кода с помощью этой утилиты в <a href="https://www.jetbrains.com/help/clion/clangformat-as-alternative-formatter.html">clion</a>.</p>
<p>Для дополнительных проверок на именование переменных, функций и прочего выполните</p>
<pre><code class="language-bash">clang-tidy main.cpp -- -std=c++17
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Что-делать-если-решение-не-проходит-в-контесте"><a class="header" href="#Что-делать-если-решение-не-проходит-в-контесте">Что делать, если решение не проходит в контесте</a></h1>
<p>Если решение работает локально, а в контесте падает, стоит поискать тест, на котором решение работает неправильно или медленно. Для этого можно запускать стресс-тесты (см. первый семинар в LMS) под <a href="./environment.html">санитайзерами</a>.</p>
<p>Ниже перечислены основные причины, почему решение может работать медленно или потреблять много памяти</p>
<h2 id="Медленный-ввод-вывод"><a class="header" href="#Медленный-ввод-вывод">Медленный ввод-вывод</a></h2>
<p>По умолчанию в C++ для <code>iostream</code> включен режим совместимости с <code>stdio</code>, который позволяет одновременно использовать оба интерфейса для ввода/вывода. В этом режиме производительность <code>std::cin</code> и <code>std::cout</code> понижается в несколько раз.
Поэтому если размер ввода/вывода имеет порядок от 100 000 чисел, вам нужно будет отключить этот режим. Делать это нужно до совершения каких-либо операций ввода-вывода, желательно первой же строкой в программе:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

int main() {
    std::ios_base::sync_with_stdio(false);
    ...
    return 0;
}
</code></pre>
<p>Также обратите внимание на то, что <code>std::cout</code> может работать слишком медленно, если вы выводите порядка 100 000 чисел или более, и при этом у <code>std::cout</code> регулярно очищается буфер. Буфер очищается при каждом выводе <code>std::endl</code>, так что в случае большого вывода лучше выводить <code>&quot;\n&quot;</code> вместо <code>std::endl</code>. Также буфер <code>std::cout</code> очищается при каждом вводе через <code>std::cin</code> — это связано с тем, что при пользовательском вводе-выводе через обычный <code>std::cin</code> и <code>std::cout</code> в консоли, необходимо показать пользователю последний вывод и очистить буфер перед тем как запрашивать очередной ввод. Эта проблема для задач с большим выводом решается с помощью вызова <code>std::cin.tie(nullptr);</code> в самом начале программы. Выполнение всех этих рекомендаций приведёт к тому, что ввод-вывод при помощи потоков <code>std::cin</code> и <code>std::cout</code> будет работать не медленнее ввода-вывода через <code>printf</code> и <code>scanf</code> на задачах с большим вводом-выводом. Подробнее см. <a href="http://stackoverflow.com/questions/9274057">здесь</a>.</p>
<h2 id="Санитайзеры-на-маленьких-тестах"><a class="header" href="#Санитайзеры-на-маленьких-тестах">Санитайзеры на маленьких тестах</a></h2>
<p>На нескольких первых маленьких тестах в контесте решение запускается с санитайзером. Санитайзер увеличивает время работы и потреблении памяти программы, поэтому если в решении выделять статический массив максимального размера (например, <code>int arr[100500]</code>), то решение может упасть с ML.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
